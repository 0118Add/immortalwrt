--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -259,7 +259,8 @@ struct event_desc {
#define OPT_TFTP_APREF_MAC 56
#define OPT_RAPID_COMMIT   57
#define OPT_UBUS           58
-#define OPT_LAST           59
+#define OPT_FILTER_AAAA    59
+#define OPT_LAST           60

#define OPTION_BITS (sizeof(unsigned int)*8)
#define OPTION_SIZE ( (OPT_LAST/OPTION_BITS)+((OPT_LAST%OPTION_BITS)!=0) )
--- a/src/option.c
+++ b/src/option.c
@@ -166,6 +166,7 @@ struct myoption {
#define LOPT_UBUS          354
#define LOPT_NAME_MATCH    355
#define LOPT_CAA           356
+#define LOPT_FILTER_AAAA   357
  
#ifdef HAVE_GETOPT_LONG
static const struct option opts[] =  
@@ -333,6 +334,7 @@ static const struct myoption opts[] =
     { "dns-loop-detect", 0, 0, LOPT_LOOP_DETECT },
     { "script-arp", 0, 0, LOPT_SCRIPT_ARP },
     { "dhcp-ttl", 1, 0 , LOPT_DHCPTTL },
+    { "filter-aaaa", 0, 0, LOPT_FILTER_AAAA },
     { "dhcp-reply-delay", 1, 0, LOPT_REPLY_DELAY },
     { "dhcp-rapid-commit", 0, 0, LOPT_RAPID_COMMIT },
     { "dumpfile", 1, 0, LOPT_DUMPFILE },
@@ -511,6 +513,7 @@ static struct {
   { LOPT_LOOP_DETECT, OPT_LOOP_DETECT, NULL, gettext_noop("Detect and remove DNS forwarding loops."), NULL },
   { LOPT_IGNORE_ADDR, ARG_DUP, "<ipaddr>", gettext_noop("Ignore DNS responses containing ipaddr."), NULL }, 
   { LOPT_DHCPTTL, ARG_ONE, "<ttl>", gettext_noop("Set TTL in DNS responses with DHCP-derived addresses."), NULL }, 
+  { LOPT_FILTER_AAAA, OPT_FILTER_AAAA, NULL, gettext_noop("Filter all AAAA requests."), NULL },
   { LOPT_REPLY_DELAY, ARG_ONE, "<integer>", gettext_noop("Delay DHCP replies for at least number of seconds."), NULL },
   { LOPT_RAPID_COMMIT, OPT_RAPID_COMMIT, NULL, gettext_noop("Enables DHCPv4 Rapid Commit option."), NULL },
   { LOPT_DUMPFILE, ARG_ONE, "<path>", gettext_noop("Path to debug packet dump file"), NULL },
--- a/src/rfc1035.c
+++ b/src/rfc1035.c
@@ -1968,6 +1968,12 @@ size_t answer_request(struct dns_header
              if (!dryrun)
                log_query(F_CONFIG | F_NEG, name, &addr, NULL);
            }
+
+          if (qtype == T_AAAA && option_bool(OPT_FILTER_AAAA) ){
+            ans = 1;
+            if (!dryrun) log_query(F_CONFIG | F_IPV6 | F_NEG, name, &addr, NULL);
+            break;
+          }
        }

       if (!ans)
        return 0; /* failed to answer a question */
     }
